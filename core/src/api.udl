namespace api {
};

// ============================================================================
// IDENTITY
// ============================================================================

// IdentityInfo — canonical identity = public_key_hex (Ed25519 hex).
// identity_id (Blake3 hash) and libp2p_peer_id are derived/operational metadata.
// Always use public_key_hex for persistence, exchange, and cross-platform resolution.
dictionary IdentityInfo {
    string? identity_id;
    string? public_key_hex;
    boolean initialized;
    string? nickname;
    string? libp2p_peer_id;
};

dictionary SignatureResult {
    bytes signature;
    string public_key_hex;
};

dictionary PreparedMessage {
    string message_id;
    bytes envelope_data;
};

// ============================================================================
// MAIN INTERFACE
// ============================================================================

interface IronCore {
    constructor();
    [Name=with_storage]
    constructor(string storage_path);

    // Lifecycle
    [Throws=IronCoreError]
    void start();
    void stop();
    boolean is_running();

    // Identity & Cryptography
    [Throws=IronCoreError]
    void initialize_identity();
    IdentityInfo get_identity_info();
    [Throws=IronCoreError]
    void set_nickname(string nickname);
    [Throws=IronCoreError]
    string export_identity_backup();
    [Throws=IronCoreError]
    void import_identity_backup(string backup);
    [Throws=IronCoreError]
    SignatureResult sign_data(bytes data);
    [Throws=IronCoreError]
    boolean verify_signature(bytes data, bytes signature, string public_key_hex);
    [Throws=IronCoreError]
    string extract_public_key_from_peer_id(string peer_id);

    // Messaging
    [Throws=IronCoreError]
    bytes prepare_message(string recipient_public_key_hex, string text);
    [Throws=IronCoreError]
    PreparedMessage prepare_message_with_id(string recipient_public_key_hex, string text);
    [Throws=IronCoreError]
    bytes prepare_receipt(string recipient_public_key_hex, string message_id);
    /// Generate a cover traffic payload — random bytes that look like an encrypted
    /// message. Broadcast via send_to_all_peers() to obscure real traffic patterns.
    /// `size_bytes` controls payload size (16-1024); values outside range are clamped.
    [Throws=IronCoreError]
    bytes prepare_cover_traffic(u32 size_bytes);
    u32 outbox_count();
    u32 inbox_count();
    boolean mark_message_sent(string message_id);

    // Delegate
    void set_delegate(CoreDelegate? delegate);
};

// ============================================================================
// CALLBACKS
// ============================================================================

callback interface CoreDelegate {
    void on_peer_discovered(string peer_id);
    void on_peer_disconnected(string peer_id);
    void on_peer_identified(string peer_id, string agent_version, sequence<string> listen_addrs);
    // sender_public_key_hex: Ed25519 hex (64 chars) — use this with prepare_receipt()
    // sender_id: Blake3 identity_id (64 hex chars) — use this for display / history
    void on_message_received(string sender_id, string sender_public_key_hex, string message_id, u64 sender_timestamp, bytes data);
    void on_receipt_received(string message_id, string status);
};

// ============================================================================
// ERROR HANDLING
// ============================================================================

[Error]
enum IronCoreError {
    "NotInitialized",
    "AlreadyRunning",
    "StorageError",
    "CryptoError",
    "NetworkError",
    "InvalidInput",
    "Internal",
};

// ============================================================================
// MOBILE SERVICE
// ============================================================================

dictionary MeshServiceConfig {
    u32 discovery_interval_ms;
    u8 battery_floor_pct;
};

enum ServiceState {
    "Stopped",
    "Starting",
    "Running",
    "Stopping",
};

/// Canonical connection-path state contract for all clients.
enum ConnectionPathState {
    "Disconnected",
    "Bootstrapping",
    "DirectPreferred",
    "RelayFallback",
    "RelayOnly",
};

enum MotionState {
    "Still",
    "Walking",
    "Running",
    "Automotive",
    "Unknown",
};

dictionary ServiceStats {
    u32 peers_discovered;
    u32 messages_relayed;
    u64 bytes_transferred;
    u64 uptime_secs;
};

interface MeshService {
    constructor(MeshServiceConfig config);
    [Name=with_storage]
    constructor(MeshServiceConfig config, string storage_path);

    [Throws=IronCoreError]
    void start();
    void stop();
    void pause();
    void resume();
    ServiceState get_state();
    ServiceStats get_stats();
    void reset_stats();
    void set_platform_bridge(PlatformBridge? bridge);

    [Throws=IronCoreError]
    void start_swarm(string listen_addr);
    SwarmBridge get_swarm_bridge();

    /// Configure bootstrap nodes for NAT traversal and internet roaming.
    /// These are multiaddr strings like "/ip4/1.2.3.4/tcp/4001" or
    /// "/dns4/bootstrap.scmessenger.net/tcp/4001".
    void set_bootstrap_nodes(sequence<string> addrs);

    /// Get the current NAT status as a string: "open", "restricted", "symmetric", or "unknown".
    string get_nat_status();
    ConnectionPathState get_connection_path_state();
    /// Export a structured diagnostics JSON payload for support and partner testing.
    string export_diagnostics();

    void update_device_state(DeviceProfile profile);
    void set_relay_budget(u32 messages_per_hour);

    void on_peer_discovered(string peer_id);
    void on_peer_disconnected(string peer_id);
    void on_data_received(string peer_id, bytes data);
    IronCore? get_core();
};

callback interface PlatformBridge {
    void on_battery_changed(u8 battery_pct, boolean is_charging);
    void on_network_changed(boolean has_wifi, boolean has_cellular);
    void on_motion_changed(MotionState motion);
    void on_ble_data_received(string peer_id, bytes data);
    void on_entering_background();
    void on_entering_foreground();
    void send_ble_packet(string peer_id, bytes data);
};

// ============================================================================
// AUTO-ADJUST ENGINE
// ============================================================================

dictionary DeviceProfile {
    u8 battery_pct;
    boolean is_charging;
    boolean has_wifi;
    MotionState motion_state;
};

enum AdjustmentProfile {
    "Maximum",
    "High",
    "Standard",
    "Reduced",
    "Minimal",
};

dictionary BleAdjustment {
    u32 scan_interval_ms;
    u32 advertise_interval_ms;
    i8 tx_power_dbm;
};

dictionary RelayAdjustment {
    u32 max_per_hour;
    u8 priority_threshold;
    u32 max_payload_bytes;
};

interface AutoAdjustEngine {
    constructor();

    AdjustmentProfile compute_profile(DeviceProfile device);
    BleAdjustment compute_ble_adjustment(AdjustmentProfile profile);
    RelayAdjustment compute_relay_adjustment(AdjustmentProfile profile);

    void override_ble_scan_interval(u32 interval_ms);
    void override_relay_max_per_hour(u32 max);
    void clear_overrides();
};

// ============================================================================
// MESH SETTINGS
// ============================================================================

enum DiscoveryMode {
    "Normal",
    "Cautious",
    "Paranoid",
};

dictionary MeshSettings {
    boolean relay_enabled;
    u32 max_relay_budget;
    u8 battery_floor;
    boolean ble_enabled;
    boolean wifi_aware_enabled;
    boolean wifi_direct_enabled;
    boolean internet_enabled;
    DiscoveryMode discovery_mode;
    boolean onion_routing;
    boolean cover_traffic_enabled;
    boolean message_padding_enabled;
    boolean timing_obfuscation_enabled;
};

interface MeshSettingsManager {
    constructor(string storage_path);

    [Throws=IronCoreError]
    MeshSettings load();

    [Throws=IronCoreError]
    void save(MeshSettings settings);

    [Throws=IronCoreError]
    void validate(MeshSettings settings);

    MeshSettings default_settings();
};

// ============================================================================
// BOOTSTRAP CONFIGURATION
// ============================================================================

// Bootstrap resolution order: env_override → remote_url fetch → static_nodes fallback.
// The BootstrapResolver deterministically applies this priority chain.
dictionary BootstrapConfig {
    // Static fallback multiaddr strings (always consulted if env/remote are empty).
    sequence<string> static_nodes;
    // Optional remote URL to fetch a JSON array of multiaddr strings.
    // Fetched with a timeout of `fetch_timeout_secs`; on failure, falls back to static_nodes.
    string? remote_url;
    // Timeout for the remote fetch, in seconds (default: 5).
    u32 fetch_timeout_secs;
    // Optional environment variable name containing a comma-separated list of multiaddrs.
    // If set and non-empty, this overrides both remote_url and static_nodes.
    string? env_override_key;
};

interface BootstrapResolver {
    constructor(BootstrapConfig config);

    /// Resolve bootstrap nodes using the priority chain: env → remote → static.
    /// This is a synchronous, deterministic resolution (remote fetch is attempted
    /// but falls back on timeout/error). Call this once at startup.
    sequence<string> resolve();

    /// Return the raw static fallback list without env/remote resolution.
    sequence<string> static_fallback();
};

// ============================================================================
// CONTACTS
// ============================================================================

dictionary Contact {
    string peer_id;
    string? nickname;       // Federated nickname (from the peer)
    string? local_nickname; // Local override set by the user
    string public_key;
    u64 added_at;
    u64? last_seen;
    string? notes;
};

interface ContactManager {
    [Throws=IronCoreError]
    constructor(string storage_path);

    [Throws=IronCoreError]
    void add(Contact contact);

    [Throws=IronCoreError]
    Contact? get(string peer_id);

    [Throws=IronCoreError]
    void remove(string peer_id);

    [Throws=IronCoreError]
    sequence<Contact> list();

    [Throws=IronCoreError]
    sequence<Contact> search(string query);

    [Throws=IronCoreError]
    void set_nickname(string peer_id, string? nickname);

    [Throws=IronCoreError]
    void set_local_nickname(string peer_id, string? nickname);

    [Throws=IronCoreError]
    void update_last_seen(string peer_id);

    u32 count();
};

// ============================================================================
// MESSAGE HISTORY
// ============================================================================

enum MessageDirection {
    "Sent",
    "Received",
};

dictionary MessageRecord {
    string id;
    MessageDirection direction;
    string peer_id;
    string content;
    u64 timestamp;
    boolean delivered;
};

dictionary HistoryStats {
    u32 total_messages;
    u32 sent_count;
    u32 received_count;
    u32 undelivered_count;
};

interface HistoryManager {
    [Throws=IronCoreError]
    constructor(string storage_path);

    [Throws=IronCoreError]
    void add(MessageRecord record);

    [Throws=IronCoreError]
    MessageRecord? get(string id);

    [Throws=IronCoreError]
    sequence<MessageRecord> recent(string? peer_filter, u32 limit);

    [Throws=IronCoreError]
    sequence<MessageRecord> conversation(string peer_id, u32 limit);

    [Throws=IronCoreError]
    void remove_conversation(string peer_id);

    [Throws=IronCoreError]
    sequence<MessageRecord> search(string query, u32 limit);

    [Throws=IronCoreError]
    void mark_delivered(string id);

    [Throws=IronCoreError]
    void clear();

    [Throws=IronCoreError]
    void clear_conversation(string peer_id);

    [Throws=IronCoreError]
    void delete(string id);

    [Throws=IronCoreError]
    HistoryStats stats();

    u32 count();

    /// Enforce a maximum message cap — keeps ``max_messages`` newest, prunes the rest.
    /// Returns the number of pruned records.
    [Throws=IronCoreError]
    u32 enforce_retention(u32 max_messages);

    /// Remove all messages older than ``before_timestamp`` (Unix epoch seconds).
    /// Returns the number of pruned records.
    [Throws=IronCoreError]
    u32 prune_before(u64 before_timestamp);
};

// ============================================================================
// CONNECTION LEDGER
// ============================================================================

dictionary LedgerEntry {
    string multiaddr;
    string? peer_id;
    string? public_key;
    string? nickname;
    u32 success_count;
    u32 failure_count;
    u64? last_seen;
    sequence<string> topics;
};

interface LedgerManager {
    constructor(string storage_path);

    [Throws=IronCoreError]
    void load();

    [Throws=IronCoreError]
    void save();

    void record_connection(string multiaddr, string peer_id);
    void record_failure(string multiaddr);
    void annotate_identity(string multiaddr, string peer_id, string? public_key, string? nickname);

    sequence<LedgerEntry> dialable_addresses();
    sequence<LedgerEntry> get_preferred_relays(u32 limit);
    sequence<string> all_known_topics();

    string summary();
};

// ============================================================================
// SWARM BRIDGE
// ============================================================================

interface SwarmBridge {
    constructor();

    [Throws=IronCoreError]
    void send_message(string peer_id, bytes data);

    [Throws=IronCoreError]
    void dial(string multiaddr);

    sequence<string> get_peers();
    sequence<string> get_listeners();
    sequence<string> get_external_addresses();
    sequence<string> get_topics();

    [Throws=IronCoreError]
    void subscribe_topic(string topic);

    [Throws=IronCoreError]
    void unsubscribe_topic(string topic);

    [Throws=IronCoreError]
    void publish_topic(string topic, bytes data);

    void shutdown();

    [Throws=IronCoreError]
    void send_to_all_peers(bytes data);
};
