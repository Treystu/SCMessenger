DHT Hyper-Optimization & Peer Wakeup StrategyThis document serves as a strategic supplement to the REMAINING_WORK_TRACKING.md. It details the architectural approach for solving the "sleeping mobile node" problem inherent in P2P networks, plans for hyper-optimizing the Distributed Hash Table (DHT), and the engineering roadmap to achieve 100% completion based on Lines of Code (LoC) estimates.1. The "Waking Peers" Solution: Decentralized Delegate NodesMobile operating systems (iOS and Android) aggressively suspend background network activity to preserve battery life, making persistent P2P connections impossible. The documented, decentralized solution is the Delegate Node (Linked Device) Proxy pattern.How It WorksInstead of relying on a centralized server to hold push notification tokens, any active, high-uptime node on the SCMessenger network can act as a linked device/delegate on behalf of a sleeping device.Delegate Selection & Registration: Before going to sleep, the mobile node (Node A) identifies 1-3 highly available nodes on the network (Node B, Node C).Token Hand-off: Node A securely shares an encrypted, anonymous push token (e.g., UnifiedPush, FCM, or APNs) or a local-network trigger payload with its delegates.DHT Pointer Updates: Node A updates its DHT Provider Record to point to the PeerIDs of its delegates, rather than its own transient IP address.Proxy Routing & Wakeup: * When Node D wants to message Node A, it queries the DHT and finds the provider records pointing to Node B and Node C.Node D sends a "wakeup request" or the encrypted message directly to the delegates.The delegate pushes a generic, metadata-free wakeup notification (e.g., { "action": "WAKE_P2P" }) to Node A.Reconnection: Node A's OS wakes the app in the background. The app re-establishes its P2P connections, pulls the actual message from the mesh, and processes it.Soft AP & Local Mesh FallbackWhile standard push notifications work over the internet, true decentralized resilience requires local capabilities.The Hypothesis: A Soft AP (Wi-Fi Direct / Hotspot) or Bluetooth Low Energy (BLE) beacon can be utilized by nearby peers to trigger a localized wakeup without internet connectivity.Implementation Plan: We will implement a Soft AP beaconing listener. Testing will tell if the OS background execution limits permit reliable Soft AP discovery while the app is suspended, or if it requires the user to manually trigger the connection.2. DHT Hyper-Optimization StrategyTo ensure message delivery is near-instantaneous even when routing through delegates, the underlying DHT (likely Kademlia-based) requires hyper-optimization tailored specifically for a messaging payload, rather than large file storage.2.1 Aggressive Provider Record CachingProblem: Standard DHT queries take multiple network hops, taking seconds to resolve.Optimization: Implement a localized LRU (Least Recently Used) cache for routing tables. If a user messages a peer frequently, the delegate pointers are cached locally with a Time-To-Live (TTL). The app will attempt a direct connection to the last known delegate before falling back to a full DHT walk.2.2 Concurrency and Quorum Tuning (Alpha/Beta Parameters)Optimization: Increase the Kad DHT concurrency parameter (alpha). Instead of querying 3 nodes simultaneously to find a peer, we will query 6-8. This uses slightly more bandwidth but drastically reduces the latency of finding a sleeping peer's delegate.Record Replication: Ensure that Delegate pointer records are published to a wider radius of peers (tuning the replication factor) to prevent dead links if a single delegate drops offline.2.3 Background DHT PruningOptimization: Actively prune "dead" nodes from the local routing table. Implement a background worker that pings known peers during the OS's allowed background execution window (e.g., iOS Background Fetch) to ensure the routing table is entirely composed of active, low-latency nodes when the user opens the app.3. Supplement: Path to 100% (Supporting Evidence & LoC Estimates)To complete the architecture outlined above and fulfill the remaining objectives in the primary tracking document, the following engineering effort is required.Note: Estimates are strictly in Lines of Code (LoC) as an objective metric of complexity, excluding automated tests and boilerplate.Phase A: Delegate Node Wakeup ArchitectureDelegate Discovery & Handshake Protocol: Logic for a node to find, rate, and securely exchange push tokens with a high-uptime peer.Estimate: ~450 LoCPush Notification Dispatcher (Agnostic): The module residing on the delegate node responsible for formatting and sending the wakeup ping (UnifiedPush/APNs/FCM).Estimate: ~350 LoCMobile Wakeup Listener: OS-specific receivers (Swift/Kotlin or React Native/Flutter bridges) to catch the silent push and initialize the P2P background node.Estimate: ~300 LoCPhase B: Soft AP & Local Network MechanicsSoft AP Beaconing & Listener: Logic to broadcast presence and listen for generic wakeup beacons via Wi-Fi Direct.Estimate: ~550 LoCConnectivity Heuristics Engine: A state machine to seamlessly switch between Internet DHT Delegate routing and Soft AP local mesh routing based on availability.Estimate: ~250 LoCPhase C: DHT Hyper-OptimizationLRU Caching Layer for Provider Records: Memory-safe caching mechanism with TTL invalidation.Estimate: ~200 LoCCustom Kademlia Parameter Overrides: Modifying default DHT routing behaviors, implementing concurrent lookups, and adjusting replication factors.Estimate: ~150 LoCBackground Table Pruning Worker: The aggressive dead-node eviction loop.Estimate: ~175 LoCPhase D: Storage & Resilience (Supporting tasks)Encrypted Offline Message Queue: Safe holding area for messages when neither the target nor their delegates are reachable, awaiting a DHT presence event.Estimate: ~350 LoCTotal Estimated Engineering Effort for 100% Completion: ~2,775 LoC (Core implementation logic).