// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(apiFFI)
import apiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_scmessenger_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_scmessenger_core_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol AutoAdjustEngineProtocol : AnyObject {
    
    func clearOverrides() 
    
    func computeBleAdjustment(profile: AdjustmentProfile)  -> BleAdjustment
    
    func computeProfile(device: DeviceProfile)  -> AdjustmentProfile
    
    func computeRelayAdjustment(profile: AdjustmentProfile)  -> RelayAdjustment
    
    func overrideBleScanInterval(intervalMs: UInt32) 
    
    func overrideRelayMaxPerHour(max: UInt32) 
    
}

open class AutoAdjustEngine:
    AutoAdjustEngineProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_scmessenger_core_fn_clone_autoadjustengine(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_scmessenger_core_fn_constructor_autoadjustengine_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_scmessenger_core_fn_free_autoadjustengine(pointer, $0) }
    }

    

    
open func clearOverrides() {try! rustCall() {
    uniffi_scmessenger_core_fn_method_autoadjustengine_clear_overrides(self.uniffiClonePointer(),$0
    )
}
}
    
open func computeBleAdjustment(profile: AdjustmentProfile) -> BleAdjustment {
    return try!  FfiConverterTypeBleAdjustment.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_autoadjustengine_compute_ble_adjustment(self.uniffiClonePointer(),
        FfiConverterTypeAdjustmentProfile.lower(profile),$0
    )
})
}
    
open func computeProfile(device: DeviceProfile) -> AdjustmentProfile {
    return try!  FfiConverterTypeAdjustmentProfile.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_autoadjustengine_compute_profile(self.uniffiClonePointer(),
        FfiConverterTypeDeviceProfile.lower(device),$0
    )
})
}
    
open func computeRelayAdjustment(profile: AdjustmentProfile) -> RelayAdjustment {
    return try!  FfiConverterTypeRelayAdjustment.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_autoadjustengine_compute_relay_adjustment(self.uniffiClonePointer(),
        FfiConverterTypeAdjustmentProfile.lower(profile),$0
    )
})
}
    
open func overrideBleScanInterval(intervalMs: UInt32) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_autoadjustengine_override_ble_scan_interval(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(intervalMs),$0
    )
}
}
    
open func overrideRelayMaxPerHour(max: UInt32) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_autoadjustengine_override_relay_max_per_hour(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(max),$0
    )
}
}
    

}

public struct FfiConverterTypeAutoAdjustEngine: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AutoAdjustEngine

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AutoAdjustEngine {
        return AutoAdjustEngine(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AutoAdjustEngine) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AutoAdjustEngine {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AutoAdjustEngine, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeAutoAdjustEngine_lift(_ pointer: UnsafeMutableRawPointer) throws -> AutoAdjustEngine {
    return try FfiConverterTypeAutoAdjustEngine.lift(pointer)
}

public func FfiConverterTypeAutoAdjustEngine_lower(_ value: AutoAdjustEngine) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAutoAdjustEngine.lower(value)
}




public protocol BootstrapResolverProtocol : AnyObject {
    
    /**
     * Resolve bootstrap nodes using the priority chain: env → remote → static.
     * This is a synchronous, deterministic resolution (remote fetch is attempted
     * but falls back on timeout/error). Call this once at startup.
     */
    func resolve()  -> [String]
    
    /**
     * Return the raw static fallback list without env/remote resolution.
     */
    func staticFallback()  -> [String]
    
}

open class BootstrapResolver:
    BootstrapResolverProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_scmessenger_core_fn_clone_bootstrapresolver(self.pointer, $0) }
    }
public convenience init(config: BootstrapConfig) {
    let pointer =
        try! rustCall() {
    uniffi_scmessenger_core_fn_constructor_bootstrapresolver_new(
        FfiConverterTypeBootstrapConfig.lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_scmessenger_core_fn_free_bootstrapresolver(pointer, $0) }
    }

    

    
    /**
     * Resolve bootstrap nodes using the priority chain: env → remote → static.
     * This is a synchronous, deterministic resolution (remote fetch is attempted
     * but falls back on timeout/error). Call this once at startup.
     */
open func resolve() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_bootstrapresolver_resolve(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the raw static fallback list without env/remote resolution.
     */
open func staticFallback() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_bootstrapresolver_static_fallback(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeBootstrapResolver: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BootstrapResolver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BootstrapResolver {
        return BootstrapResolver(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BootstrapResolver) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BootstrapResolver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BootstrapResolver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBootstrapResolver_lift(_ pointer: UnsafeMutableRawPointer) throws -> BootstrapResolver {
    return try FfiConverterTypeBootstrapResolver.lift(pointer)
}

public func FfiConverterTypeBootstrapResolver_lower(_ value: BootstrapResolver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBootstrapResolver.lower(value)
}




public protocol ContactManagerProtocol : AnyObject {
    
    func add(contact: Contact) throws 
    
    func count()  -> UInt32
    
    func flush() 
    
    func get(peerId: String) throws  -> Contact?
    
    func list() throws  -> [Contact]
    
    func remove(peerId: String) throws 
    
    func search(query: String) throws  -> [Contact]
    
    func setLocalNickname(peerId: String, nickname: String?) throws 
    
    func setNickname(peerId: String, nickname: String?) throws 
    
    func updateLastSeen(peerId: String) throws 
    
}

open class ContactManager:
    ContactManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_scmessenger_core_fn_clone_contactmanager(self.pointer, $0) }
    }
public convenience init(storagePath: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_constructor_contactmanager_new(
        FfiConverterString.lower(storagePath),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_scmessenger_core_fn_free_contactmanager(pointer, $0) }
    }

    

    
open func add(contact: Contact)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_contactmanager_add(self.uniffiClonePointer(),
        FfiConverterTypeContact.lower(contact),$0
    )
}
}
    
open func count() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_contactmanager_count(self.uniffiClonePointer(),$0
    )
})
}
    
open func flush() {try! rustCall() {
    uniffi_scmessenger_core_fn_method_contactmanager_flush(self.uniffiClonePointer(),$0
    )
}
}
    
open func get(peerId: String)throws  -> Contact? {
    return try  FfiConverterOptionTypeContact.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_contactmanager_get(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),$0
    )
})
}
    
open func list()throws  -> [Contact] {
    return try  FfiConverterSequenceTypeContact.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_contactmanager_list(self.uniffiClonePointer(),$0
    )
})
}
    
open func remove(peerId: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_contactmanager_remove(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),$0
    )
}
}
    
open func search(query: String)throws  -> [Contact] {
    return try  FfiConverterSequenceTypeContact.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_contactmanager_search(self.uniffiClonePointer(),
        FfiConverterString.lower(query),$0
    )
})
}
    
open func setLocalNickname(peerId: String, nickname: String?)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_contactmanager_set_local_nickname(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),
        FfiConverterOptionString.lower(nickname),$0
    )
}
}
    
open func setNickname(peerId: String, nickname: String?)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_contactmanager_set_nickname(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),
        FfiConverterOptionString.lower(nickname),$0
    )
}
}
    
open func updateLastSeen(peerId: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_contactmanager_update_last_seen(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),$0
    )
}
}
    

}

public struct FfiConverterTypeContactManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ContactManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ContactManager {
        return ContactManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ContactManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContactManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ContactManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeContactManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> ContactManager {
    return try FfiConverterTypeContactManager.lift(pointer)
}

public func FfiConverterTypeContactManager_lower(_ value: ContactManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeContactManager.lower(value)
}




public protocol HistoryManagerProtocol : AnyObject {
    
    func add(record: MessageRecord) throws 
    
    func clear() throws 
    
    func clearConversation(peerId: String) throws 
    
    func conversation(peerId: String, limit: UInt32) throws  -> [MessageRecord]
    
    func count()  -> UInt32
    
    func delete(id: String) throws 
    
    /**
     * Enforce a maximum message cap — keeps ``max_messages`` newest, prunes the rest.
     * Returns the number of pruned records.
     */
    func enforceRetention(maxMessages: UInt32) throws  -> UInt32
    
    func flush() 
    
    func get(id: String) throws  -> MessageRecord?
    
    func markDelivered(id: String) throws 
    
    /**
     * Remove all messages older than ``before_timestamp`` (Unix epoch seconds).
     * Returns the number of pruned records.
     */
    func pruneBefore(beforeTimestamp: UInt64) throws  -> UInt32
    
    func recent(peerFilter: String?, limit: UInt32) throws  -> [MessageRecord]
    
    func removeConversation(peerId: String) throws 
    
    func search(query: String, limit: UInt32) throws  -> [MessageRecord]
    
    func stats() throws  -> HistoryStats
    
}

open class HistoryManager:
    HistoryManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_scmessenger_core_fn_clone_historymanager(self.pointer, $0) }
    }
public convenience init(storagePath: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_constructor_historymanager_new(
        FfiConverterString.lower(storagePath),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_scmessenger_core_fn_free_historymanager(pointer, $0) }
    }

    

    
open func add(record: MessageRecord)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_add(self.uniffiClonePointer(),
        FfiConverterTypeMessageRecord.lower(record),$0
    )
}
}
    
open func clear()throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_clear(self.uniffiClonePointer(),$0
    )
}
}
    
open func clearConversation(peerId: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_clear_conversation(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),$0
    )
}
}
    
open func conversation(peerId: String, limit: UInt32)throws  -> [MessageRecord] {
    return try  FfiConverterSequenceTypeMessageRecord.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_conversation(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),
        FfiConverterUInt32.lower(limit),$0
    )
})
}
    
open func count() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_historymanager_count(self.uniffiClonePointer(),$0
    )
})
}
    
open func delete(id: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_delete(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
}
}
    
    /**
     * Enforce a maximum message cap — keeps ``max_messages`` newest, prunes the rest.
     * Returns the number of pruned records.
     */
open func enforceRetention(maxMessages: UInt32)throws  -> UInt32 {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_enforce_retention(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(maxMessages),$0
    )
})
}
    
open func flush() {try! rustCall() {
    uniffi_scmessenger_core_fn_method_historymanager_flush(self.uniffiClonePointer(),$0
    )
}
}
    
open func get(id: String)throws  -> MessageRecord? {
    return try  FfiConverterOptionTypeMessageRecord.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_get(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
})
}
    
open func markDelivered(id: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_mark_delivered(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
}
}
    
    /**
     * Remove all messages older than ``before_timestamp`` (Unix epoch seconds).
     * Returns the number of pruned records.
     */
open func pruneBefore(beforeTimestamp: UInt64)throws  -> UInt32 {
    return try  FfiConverterUInt32.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_prune_before(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(beforeTimestamp),$0
    )
})
}
    
open func recent(peerFilter: String?, limit: UInt32)throws  -> [MessageRecord] {
    return try  FfiConverterSequenceTypeMessageRecord.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_recent(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(peerFilter),
        FfiConverterUInt32.lower(limit),$0
    )
})
}
    
open func removeConversation(peerId: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_remove_conversation(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),$0
    )
}
}
    
open func search(query: String, limit: UInt32)throws  -> [MessageRecord] {
    return try  FfiConverterSequenceTypeMessageRecord.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_search(self.uniffiClonePointer(),
        FfiConverterString.lower(query),
        FfiConverterUInt32.lower(limit),$0
    )
})
}
    
open func stats()throws  -> HistoryStats {
    return try  FfiConverterTypeHistoryStats.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_historymanager_stats(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeHistoryManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HistoryManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HistoryManager {
        return HistoryManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HistoryManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoryManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HistoryManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeHistoryManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> HistoryManager {
    return try FfiConverterTypeHistoryManager.lift(pointer)
}

public func FfiConverterTypeHistoryManager_lower(_ value: HistoryManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHistoryManager.lower(value)
}




public protocol IronCoreProtocol : AnyObject {
    
    func exportIdentityBackup() throws  -> String
    
    func extractPublicKeyFromPeerId(peerId: String) throws  -> String
    
    func getIdentityInfo()  -> IdentityInfo
    
    func importIdentityBackup(backup: String) throws 
    
    func inboxCount()  -> UInt32
    
    func initializeIdentity() throws 
    
    func isRunning()  -> Bool
    
    func markMessageSent(messageId: String)  -> Bool
    
    func outboxCount()  -> UInt32
    
    /**
     * Generate a cover traffic payload — random bytes that look like an encrypted
     * message. Broadcast via send_to_all_peers() to obscure real traffic patterns.
     * `size_bytes` controls payload size (16-1024); values outside range are clamped.
     */
    func prepareCoverTraffic(sizeBytes: UInt32) throws  -> Data
    
    func prepareMessage(recipientPublicKeyHex: String, text: String) throws  -> Data
    
    func prepareMessageWithId(recipientPublicKeyHex: String, text: String) throws  -> PreparedMessage
    
    func prepareReceipt(recipientPublicKeyHex: String, messageId: String) throws  -> Data
    
    func setDelegate(delegate: CoreDelegate?) 
    
    func setNickname(nickname: String) throws 
    
    func signData(data: Data) throws  -> SignatureResult
    
    func start() throws 
    
    func stop() 
    
    func verifySignature(data: Data, signature: Data, publicKeyHex: String) throws  -> Bool
    
}

open class IronCore:
    IronCoreProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_scmessenger_core_fn_clone_ironcore(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_scmessenger_core_fn_constructor_ironcore_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_scmessenger_core_fn_free_ironcore(pointer, $0) }
    }

    
public static func withStorage(storagePath: String) -> IronCore {
    return try!  FfiConverterTypeIronCore.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_constructor_ironcore_with_storage(
        FfiConverterString.lower(storagePath),$0
    )
})
}
    

    
open func exportIdentityBackup()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_export_identity_backup(self.uniffiClonePointer(),$0
    )
})
}
    
open func extractPublicKeyFromPeerId(peerId: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_extract_public_key_from_peer_id(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),$0
    )
})
}
    
open func getIdentityInfo() -> IdentityInfo {
    return try!  FfiConverterTypeIdentityInfo.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_ironcore_get_identity_info(self.uniffiClonePointer(),$0
    )
})
}
    
open func importIdentityBackup(backup: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_import_identity_backup(self.uniffiClonePointer(),
        FfiConverterString.lower(backup),$0
    )
}
}
    
open func inboxCount() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_ironcore_inbox_count(self.uniffiClonePointer(),$0
    )
})
}
    
open func initializeIdentity()throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_initialize_identity(self.uniffiClonePointer(),$0
    )
}
}
    
open func isRunning() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_ironcore_is_running(self.uniffiClonePointer(),$0
    )
})
}
    
open func markMessageSent(messageId: String) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_ironcore_mark_message_sent(self.uniffiClonePointer(),
        FfiConverterString.lower(messageId),$0
    )
})
}
    
open func outboxCount() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_ironcore_outbox_count(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Generate a cover traffic payload — random bytes that look like an encrypted
     * message. Broadcast via send_to_all_peers() to obscure real traffic patterns.
     * `size_bytes` controls payload size (16-1024); values outside range are clamped.
     */
open func prepareCoverTraffic(sizeBytes: UInt32)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_prepare_cover_traffic(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(sizeBytes),$0
    )
})
}
    
open func prepareMessage(recipientPublicKeyHex: String, text: String)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_prepare_message(self.uniffiClonePointer(),
        FfiConverterString.lower(recipientPublicKeyHex),
        FfiConverterString.lower(text),$0
    )
})
}
    
open func prepareMessageWithId(recipientPublicKeyHex: String, text: String)throws  -> PreparedMessage {
    return try  FfiConverterTypePreparedMessage.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_prepare_message_with_id(self.uniffiClonePointer(),
        FfiConverterString.lower(recipientPublicKeyHex),
        FfiConverterString.lower(text),$0
    )
})
}
    
open func prepareReceipt(recipientPublicKeyHex: String, messageId: String)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_prepare_receipt(self.uniffiClonePointer(),
        FfiConverterString.lower(recipientPublicKeyHex),
        FfiConverterString.lower(messageId),$0
    )
})
}
    
open func setDelegate(delegate: CoreDelegate?) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_ironcore_set_delegate(self.uniffiClonePointer(),
        FfiConverterOptionCallbackInterfaceCoreDelegate.lower(delegate),$0
    )
}
}
    
open func setNickname(nickname: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_set_nickname(self.uniffiClonePointer(),
        FfiConverterString.lower(nickname),$0
    )
}
}
    
open func signData(data: Data)throws  -> SignatureResult {
    return try  FfiConverterTypeSignatureResult.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_sign_data(self.uniffiClonePointer(),
        FfiConverterData.lower(data),$0
    )
})
}
    
open func start()throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_start(self.uniffiClonePointer(),$0
    )
}
}
    
open func stop() {try! rustCall() {
    uniffi_scmessenger_core_fn_method_ironcore_stop(self.uniffiClonePointer(),$0
    )
}
}
    
open func verifySignature(data: Data, signature: Data, publicKeyHex: String)throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ironcore_verify_signature(self.uniffiClonePointer(),
        FfiConverterData.lower(data),
        FfiConverterData.lower(signature),
        FfiConverterString.lower(publicKeyHex),$0
    )
})
}
    

}

public struct FfiConverterTypeIronCore: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IronCore

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IronCore {
        return IronCore(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IronCore) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IronCore {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IronCore, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeIronCore_lift(_ pointer: UnsafeMutableRawPointer) throws -> IronCore {
    return try FfiConverterTypeIronCore.lift(pointer)
}

public func FfiConverterTypeIronCore_lower(_ value: IronCore) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIronCore.lower(value)
}




public protocol LedgerManagerProtocol : AnyObject {
    
    func allKnownTopics()  -> [String]
    
    func annotateIdentity(multiaddr: String, peerId: String, publicKey: String?, nickname: String?) 
    
    func dialableAddresses()  -> [LedgerEntry]
    
    func getPreferredRelays(limit: UInt32)  -> [LedgerEntry]
    
    func load() throws 
    
    func recordConnection(multiaddr: String, peerId: String) 
    
    func recordFailure(multiaddr: String) 
    
    func save() throws 
    
    func summary()  -> String
    
}

open class LedgerManager:
    LedgerManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_scmessenger_core_fn_clone_ledgermanager(self.pointer, $0) }
    }
public convenience init(storagePath: String) {
    let pointer =
        try! rustCall() {
    uniffi_scmessenger_core_fn_constructor_ledgermanager_new(
        FfiConverterString.lower(storagePath),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_scmessenger_core_fn_free_ledgermanager(pointer, $0) }
    }

    

    
open func allKnownTopics() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_ledgermanager_all_known_topics(self.uniffiClonePointer(),$0
    )
})
}
    
open func annotateIdentity(multiaddr: String, peerId: String, publicKey: String?, nickname: String?) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_ledgermanager_annotate_identity(self.uniffiClonePointer(),
        FfiConverterString.lower(multiaddr),
        FfiConverterString.lower(peerId),
        FfiConverterOptionString.lower(publicKey),
        FfiConverterOptionString.lower(nickname),$0
    )
}
}
    
open func dialableAddresses() -> [LedgerEntry] {
    return try!  FfiConverterSequenceTypeLedgerEntry.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_ledgermanager_dialable_addresses(self.uniffiClonePointer(),$0
    )
})
}
    
open func getPreferredRelays(limit: UInt32) -> [LedgerEntry] {
    return try!  FfiConverterSequenceTypeLedgerEntry.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_ledgermanager_get_preferred_relays(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(limit),$0
    )
})
}
    
open func load()throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ledgermanager_load(self.uniffiClonePointer(),$0
    )
}
}
    
open func recordConnection(multiaddr: String, peerId: String) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_ledgermanager_record_connection(self.uniffiClonePointer(),
        FfiConverterString.lower(multiaddr),
        FfiConverterString.lower(peerId),$0
    )
}
}
    
open func recordFailure(multiaddr: String) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_ledgermanager_record_failure(self.uniffiClonePointer(),
        FfiConverterString.lower(multiaddr),$0
    )
}
}
    
open func save()throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_ledgermanager_save(self.uniffiClonePointer(),$0
    )
}
}
    
open func summary() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_ledgermanager_summary(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeLedgerManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LedgerManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LedgerManager {
        return LedgerManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LedgerManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LedgerManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeLedgerManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> LedgerManager {
    return try FfiConverterTypeLedgerManager.lift(pointer)
}

public func FfiConverterTypeLedgerManager_lower(_ value: LedgerManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLedgerManager.lower(value)
}




public protocol MeshServiceProtocol : AnyObject {
    
    /**
     * Export a structured diagnostics JSON payload for support and partner testing.
     */
    func exportDiagnostics()  -> String
    
    func getConnectionPathState()  -> ConnectionPathState
    
    func getCore()  -> IronCore?
    
    /**
     * Get the current NAT status as a string: "open", "restricted", "symmetric", or "unknown".
     */
    func getNatStatus()  -> String
    
    func getState()  -> ServiceState
    
    func getStats()  -> ServiceStats
    
    func getSwarmBridge()  -> SwarmBridge
    
    func onDataReceived(peerId: String, data: Data) 
    
    func onPeerDisconnected(peerId: String) 
    
    func onPeerDiscovered(peerId: String) 
    
    func pause() 
    
    func resetStats() 
    
    func resume() 
    
    /**
     * Configure bootstrap nodes for NAT traversal and internet roaming.
     * These are multiaddr strings like "/ip4/1.2.3.4/tcp/4001" or
     * "/dns4/bootstrap.scmessenger.net/tcp/4001".
     */
    func setBootstrapNodes(addrs: [String]) 
    
    func setPlatformBridge(bridge: PlatformBridge?) 
    
    func setRelayBudget(messagesPerHour: UInt32) 
    
    func start() throws 
    
    func startSwarm(listenAddr: String) throws 
    
    func stop() 
    
    func updateDeviceState(profile: DeviceProfile) 
    
}

open class MeshService:
    MeshServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_scmessenger_core_fn_clone_meshservice(self.pointer, $0) }
    }
public convenience init(config: MeshServiceConfig) {
    let pointer =
        try! rustCall() {
    uniffi_scmessenger_core_fn_constructor_meshservice_new(
        FfiConverterTypeMeshServiceConfig.lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_scmessenger_core_fn_free_meshservice(pointer, $0) }
    }

    
public static func withStorage(config: MeshServiceConfig, storagePath: String) -> MeshService {
    return try!  FfiConverterTypeMeshService.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_constructor_meshservice_with_storage(
        FfiConverterTypeMeshServiceConfig.lower(config),
        FfiConverterString.lower(storagePath),$0
    )
})
}
    

    
    /**
     * Export a structured diagnostics JSON payload for support and partner testing.
     */
open func exportDiagnostics() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_export_diagnostics(self.uniffiClonePointer(),$0
    )
})
}
    
open func getConnectionPathState() -> ConnectionPathState {
    return try!  FfiConverterTypeConnectionPathState.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_get_connection_path_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func getCore() -> IronCore? {
    return try!  FfiConverterOptionTypeIronCore.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_get_core(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the current NAT status as a string: "open", "restricted", "symmetric", or "unknown".
     */
open func getNatStatus() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_get_nat_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func getState() -> ServiceState {
    return try!  FfiConverterTypeServiceState.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_get_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func getStats() -> ServiceStats {
    return try!  FfiConverterTypeServiceStats.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_get_stats(self.uniffiClonePointer(),$0
    )
})
}
    
open func getSwarmBridge() -> SwarmBridge {
    return try!  FfiConverterTypeSwarmBridge.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_get_swarm_bridge(self.uniffiClonePointer(),$0
    )
})
}
    
open func onDataReceived(peerId: String, data: Data) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_on_data_received(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),
        FfiConverterData.lower(data),$0
    )
}
}
    
open func onPeerDisconnected(peerId: String) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_on_peer_disconnected(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),$0
    )
}
}
    
open func onPeerDiscovered(peerId: String) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_on_peer_discovered(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),$0
    )
}
}
    
open func pause() {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_pause(self.uniffiClonePointer(),$0
    )
}
}
    
open func resetStats() {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_reset_stats(self.uniffiClonePointer(),$0
    )
}
}
    
open func resume() {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_resume(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Configure bootstrap nodes for NAT traversal and internet roaming.
     * These are multiaddr strings like "/ip4/1.2.3.4/tcp/4001" or
     * "/dns4/bootstrap.scmessenger.net/tcp/4001".
     */
open func setBootstrapNodes(addrs: [String]) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_set_bootstrap_nodes(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(addrs),$0
    )
}
}
    
open func setPlatformBridge(bridge: PlatformBridge?) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_set_platform_bridge(self.uniffiClonePointer(),
        FfiConverterOptionCallbackInterfacePlatformBridge.lower(bridge),$0
    )
}
}
    
open func setRelayBudget(messagesPerHour: UInt32) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_set_relay_budget(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(messagesPerHour),$0
    )
}
}
    
open func start()throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_meshservice_start(self.uniffiClonePointer(),$0
    )
}
}
    
open func startSwarm(listenAddr: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_meshservice_start_swarm(self.uniffiClonePointer(),
        FfiConverterString.lower(listenAddr),$0
    )
}
}
    
open func stop() {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_stop(self.uniffiClonePointer(),$0
    )
}
}
    
open func updateDeviceState(profile: DeviceProfile) {try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshservice_update_device_state(self.uniffiClonePointer(),
        FfiConverterTypeDeviceProfile.lower(profile),$0
    )
}
}
    

}

public struct FfiConverterTypeMeshService: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MeshService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MeshService {
        return MeshService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MeshService) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MeshService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MeshService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMeshService_lift(_ pointer: UnsafeMutableRawPointer) throws -> MeshService {
    return try FfiConverterTypeMeshService.lift(pointer)
}

public func FfiConverterTypeMeshService_lower(_ value: MeshService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMeshService.lower(value)
}




public protocol MeshSettingsManagerProtocol : AnyObject {
    
    func defaultSettings()  -> MeshSettings
    
    func load() throws  -> MeshSettings
    
    func save(settings: MeshSettings) throws 
    
    func validate(settings: MeshSettings) throws 
    
}

open class MeshSettingsManager:
    MeshSettingsManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_scmessenger_core_fn_clone_meshsettingsmanager(self.pointer, $0) }
    }
public convenience init(storagePath: String) {
    let pointer =
        try! rustCall() {
    uniffi_scmessenger_core_fn_constructor_meshsettingsmanager_new(
        FfiConverterString.lower(storagePath),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_scmessenger_core_fn_free_meshsettingsmanager(pointer, $0) }
    }

    

    
open func defaultSettings() -> MeshSettings {
    return try!  FfiConverterTypeMeshSettings.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_meshsettingsmanager_default_settings(self.uniffiClonePointer(),$0
    )
})
}
    
open func load()throws  -> MeshSettings {
    return try  FfiConverterTypeMeshSettings.lift(try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_meshsettingsmanager_load(self.uniffiClonePointer(),$0
    )
})
}
    
open func save(settings: MeshSettings)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_meshsettingsmanager_save(self.uniffiClonePointer(),
        FfiConverterTypeMeshSettings.lower(settings),$0
    )
}
}
    
open func validate(settings: MeshSettings)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_meshsettingsmanager_validate(self.uniffiClonePointer(),
        FfiConverterTypeMeshSettings.lower(settings),$0
    )
}
}
    

}

public struct FfiConverterTypeMeshSettingsManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MeshSettingsManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MeshSettingsManager {
        return MeshSettingsManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MeshSettingsManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MeshSettingsManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MeshSettingsManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeMeshSettingsManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> MeshSettingsManager {
    return try FfiConverterTypeMeshSettingsManager.lift(pointer)
}

public func FfiConverterTypeMeshSettingsManager_lower(_ value: MeshSettingsManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMeshSettingsManager.lower(value)
}




public protocol SwarmBridgeProtocol : AnyObject {
    
    func dial(multiaddr: String) throws 
    
    func getExternalAddresses()  -> [String]
    
    func getListeners()  -> [String]
    
    func getPeers()  -> [String]
    
    func getTopics()  -> [String]
    
    func publishTopic(topic: String, data: Data) throws 
    
    func sendMessage(peerId: String, data: Data) throws 
    
    func sendToAllPeers(data: Data) throws 
    
    func shutdown() 
    
    func subscribeTopic(topic: String) throws 
    
    func unsubscribeTopic(topic: String) throws 
    
}

open class SwarmBridge:
    SwarmBridgeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_scmessenger_core_fn_clone_swarmbridge(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_scmessenger_core_fn_constructor_swarmbridge_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_scmessenger_core_fn_free_swarmbridge(pointer, $0) }
    }

    

    
open func dial(multiaddr: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_swarmbridge_dial(self.uniffiClonePointer(),
        FfiConverterString.lower(multiaddr),$0
    )
}
}
    
open func getExternalAddresses() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_swarmbridge_get_external_addresses(self.uniffiClonePointer(),$0
    )
})
}
    
open func getListeners() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_swarmbridge_get_listeners(self.uniffiClonePointer(),$0
    )
})
}
    
open func getPeers() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_swarmbridge_get_peers(self.uniffiClonePointer(),$0
    )
})
}
    
open func getTopics() -> [String] {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_scmessenger_core_fn_method_swarmbridge_get_topics(self.uniffiClonePointer(),$0
    )
})
}
    
open func publishTopic(topic: String, data: Data)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_swarmbridge_publish_topic(self.uniffiClonePointer(),
        FfiConverterString.lower(topic),
        FfiConverterData.lower(data),$0
    )
}
}
    
open func sendMessage(peerId: String, data: Data)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_swarmbridge_send_message(self.uniffiClonePointer(),
        FfiConverterString.lower(peerId),
        FfiConverterData.lower(data),$0
    )
}
}
    
open func sendToAllPeers(data: Data)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_swarmbridge_send_to_all_peers(self.uniffiClonePointer(),
        FfiConverterData.lower(data),$0
    )
}
}
    
open func shutdown() {try! rustCall() {
    uniffi_scmessenger_core_fn_method_swarmbridge_shutdown(self.uniffiClonePointer(),$0
    )
}
}
    
open func subscribeTopic(topic: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_swarmbridge_subscribe_topic(self.uniffiClonePointer(),
        FfiConverterString.lower(topic),$0
    )
}
}
    
open func unsubscribeTopic(topic: String)throws  {try rustCallWithError(FfiConverterTypeIronCoreError.lift) {
    uniffi_scmessenger_core_fn_method_swarmbridge_unsubscribe_topic(self.uniffiClonePointer(),
        FfiConverterString.lower(topic),$0
    )
}
}
    

}

public struct FfiConverterTypeSwarmBridge: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SwarmBridge

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SwarmBridge {
        return SwarmBridge(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SwarmBridge) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwarmBridge {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SwarmBridge, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSwarmBridge_lift(_ pointer: UnsafeMutableRawPointer) throws -> SwarmBridge {
    return try FfiConverterTypeSwarmBridge.lift(pointer)
}

public func FfiConverterTypeSwarmBridge_lower(_ value: SwarmBridge) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSwarmBridge.lower(value)
}


public struct BleAdjustment {
    public var scanIntervalMs: UInt32
    public var advertiseIntervalMs: UInt32
    public var txPowerDbm: Int8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(scanIntervalMs: UInt32, advertiseIntervalMs: UInt32, txPowerDbm: Int8) {
        self.scanIntervalMs = scanIntervalMs
        self.advertiseIntervalMs = advertiseIntervalMs
        self.txPowerDbm = txPowerDbm
    }
}



extension BleAdjustment: Equatable, Hashable {
    public static func ==(lhs: BleAdjustment, rhs: BleAdjustment) -> Bool {
        if lhs.scanIntervalMs != rhs.scanIntervalMs {
            return false
        }
        if lhs.advertiseIntervalMs != rhs.advertiseIntervalMs {
            return false
        }
        if lhs.txPowerDbm != rhs.txPowerDbm {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(scanIntervalMs)
        hasher.combine(advertiseIntervalMs)
        hasher.combine(txPowerDbm)
    }
}


public struct FfiConverterTypeBleAdjustment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BleAdjustment {
        return
            try BleAdjustment(
                scanIntervalMs: FfiConverterUInt32.read(from: &buf), 
                advertiseIntervalMs: FfiConverterUInt32.read(from: &buf), 
                txPowerDbm: FfiConverterInt8.read(from: &buf)
        )
    }

    public static func write(_ value: BleAdjustment, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.scanIntervalMs, into: &buf)
        FfiConverterUInt32.write(value.advertiseIntervalMs, into: &buf)
        FfiConverterInt8.write(value.txPowerDbm, into: &buf)
    }
}


public func FfiConverterTypeBleAdjustment_lift(_ buf: RustBuffer) throws -> BleAdjustment {
    return try FfiConverterTypeBleAdjustment.lift(buf)
}

public func FfiConverterTypeBleAdjustment_lower(_ value: BleAdjustment) -> RustBuffer {
    return FfiConverterTypeBleAdjustment.lower(value)
}


public struct BootstrapConfig {
    public var staticNodes: [String]
    public var remoteUrl: String?
    public var fetchTimeoutSecs: UInt32
    public var envOverrideKey: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(staticNodes: [String], remoteUrl: String?, fetchTimeoutSecs: UInt32, envOverrideKey: String?) {
        self.staticNodes = staticNodes
        self.remoteUrl = remoteUrl
        self.fetchTimeoutSecs = fetchTimeoutSecs
        self.envOverrideKey = envOverrideKey
    }
}



extension BootstrapConfig: Equatable, Hashable {
    public static func ==(lhs: BootstrapConfig, rhs: BootstrapConfig) -> Bool {
        if lhs.staticNodes != rhs.staticNodes {
            return false
        }
        if lhs.remoteUrl != rhs.remoteUrl {
            return false
        }
        if lhs.fetchTimeoutSecs != rhs.fetchTimeoutSecs {
            return false
        }
        if lhs.envOverrideKey != rhs.envOverrideKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(staticNodes)
        hasher.combine(remoteUrl)
        hasher.combine(fetchTimeoutSecs)
        hasher.combine(envOverrideKey)
    }
}


public struct FfiConverterTypeBootstrapConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BootstrapConfig {
        return
            try BootstrapConfig(
                staticNodes: FfiConverterSequenceString.read(from: &buf), 
                remoteUrl: FfiConverterOptionString.read(from: &buf), 
                fetchTimeoutSecs: FfiConverterUInt32.read(from: &buf), 
                envOverrideKey: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: BootstrapConfig, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.staticNodes, into: &buf)
        FfiConverterOptionString.write(value.remoteUrl, into: &buf)
        FfiConverterUInt32.write(value.fetchTimeoutSecs, into: &buf)
        FfiConverterOptionString.write(value.envOverrideKey, into: &buf)
    }
}


public func FfiConverterTypeBootstrapConfig_lift(_ buf: RustBuffer) throws -> BootstrapConfig {
    return try FfiConverterTypeBootstrapConfig.lift(buf)
}

public func FfiConverterTypeBootstrapConfig_lower(_ value: BootstrapConfig) -> RustBuffer {
    return FfiConverterTypeBootstrapConfig.lower(value)
}


public struct Contact {
    public var peerId: String
    public var nickname: String?
    public var localNickname: String?
    public var publicKey: String
    public var addedAt: UInt64
    public var lastSeen: UInt64?
    public var notes: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(peerId: String, nickname: String?, localNickname: String?, publicKey: String, addedAt: UInt64, lastSeen: UInt64?, notes: String?) {
        self.peerId = peerId
        self.nickname = nickname
        self.localNickname = localNickname
        self.publicKey = publicKey
        self.addedAt = addedAt
        self.lastSeen = lastSeen
        self.notes = notes
    }
}



extension Contact: Equatable, Hashable {
    public static func ==(lhs: Contact, rhs: Contact) -> Bool {
        if lhs.peerId != rhs.peerId {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.localNickname != rhs.localNickname {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.addedAt != rhs.addedAt {
            return false
        }
        if lhs.lastSeen != rhs.lastSeen {
            return false
        }
        if lhs.notes != rhs.notes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(peerId)
        hasher.combine(nickname)
        hasher.combine(localNickname)
        hasher.combine(publicKey)
        hasher.combine(addedAt)
        hasher.combine(lastSeen)
        hasher.combine(notes)
    }
}


public struct FfiConverterTypeContact: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Contact {
        return
            try Contact(
                peerId: FfiConverterString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                localNickname: FfiConverterOptionString.read(from: &buf), 
                publicKey: FfiConverterString.read(from: &buf), 
                addedAt: FfiConverterUInt64.read(from: &buf), 
                lastSeen: FfiConverterOptionUInt64.read(from: &buf), 
                notes: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Contact, into buf: inout [UInt8]) {
        FfiConverterString.write(value.peerId, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.localNickname, into: &buf)
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterUInt64.write(value.addedAt, into: &buf)
        FfiConverterOptionUInt64.write(value.lastSeen, into: &buf)
        FfiConverterOptionString.write(value.notes, into: &buf)
    }
}


public func FfiConverterTypeContact_lift(_ buf: RustBuffer) throws -> Contact {
    return try FfiConverterTypeContact.lift(buf)
}

public func FfiConverterTypeContact_lower(_ value: Contact) -> RustBuffer {
    return FfiConverterTypeContact.lower(value)
}


public struct DeviceProfile {
    public var batteryPct: UInt8
    public var isCharging: Bool
    public var hasWifi: Bool
    public var motionState: MotionState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(batteryPct: UInt8, isCharging: Bool, hasWifi: Bool, motionState: MotionState) {
        self.batteryPct = batteryPct
        self.isCharging = isCharging
        self.hasWifi = hasWifi
        self.motionState = motionState
    }
}



extension DeviceProfile: Equatable, Hashable {
    public static func ==(lhs: DeviceProfile, rhs: DeviceProfile) -> Bool {
        if lhs.batteryPct != rhs.batteryPct {
            return false
        }
        if lhs.isCharging != rhs.isCharging {
            return false
        }
        if lhs.hasWifi != rhs.hasWifi {
            return false
        }
        if lhs.motionState != rhs.motionState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(batteryPct)
        hasher.combine(isCharging)
        hasher.combine(hasWifi)
        hasher.combine(motionState)
    }
}


public struct FfiConverterTypeDeviceProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceProfile {
        return
            try DeviceProfile(
                batteryPct: FfiConverterUInt8.read(from: &buf), 
                isCharging: FfiConverterBool.read(from: &buf), 
                hasWifi: FfiConverterBool.read(from: &buf), 
                motionState: FfiConverterTypeMotionState.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceProfile, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.batteryPct, into: &buf)
        FfiConverterBool.write(value.isCharging, into: &buf)
        FfiConverterBool.write(value.hasWifi, into: &buf)
        FfiConverterTypeMotionState.write(value.motionState, into: &buf)
    }
}


public func FfiConverterTypeDeviceProfile_lift(_ buf: RustBuffer) throws -> DeviceProfile {
    return try FfiConverterTypeDeviceProfile.lift(buf)
}

public func FfiConverterTypeDeviceProfile_lower(_ value: DeviceProfile) -> RustBuffer {
    return FfiConverterTypeDeviceProfile.lower(value)
}


public struct HistoryStats {
    public var totalMessages: UInt32
    public var sentCount: UInt32
    public var receivedCount: UInt32
    public var undeliveredCount: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(totalMessages: UInt32, sentCount: UInt32, receivedCount: UInt32, undeliveredCount: UInt32) {
        self.totalMessages = totalMessages
        self.sentCount = sentCount
        self.receivedCount = receivedCount
        self.undeliveredCount = undeliveredCount
    }
}



extension HistoryStats: Equatable, Hashable {
    public static func ==(lhs: HistoryStats, rhs: HistoryStats) -> Bool {
        if lhs.totalMessages != rhs.totalMessages {
            return false
        }
        if lhs.sentCount != rhs.sentCount {
            return false
        }
        if lhs.receivedCount != rhs.receivedCount {
            return false
        }
        if lhs.undeliveredCount != rhs.undeliveredCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(totalMessages)
        hasher.combine(sentCount)
        hasher.combine(receivedCount)
        hasher.combine(undeliveredCount)
    }
}


public struct FfiConverterTypeHistoryStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoryStats {
        return
            try HistoryStats(
                totalMessages: FfiConverterUInt32.read(from: &buf), 
                sentCount: FfiConverterUInt32.read(from: &buf), 
                receivedCount: FfiConverterUInt32.read(from: &buf), 
                undeliveredCount: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: HistoryStats, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.totalMessages, into: &buf)
        FfiConverterUInt32.write(value.sentCount, into: &buf)
        FfiConverterUInt32.write(value.receivedCount, into: &buf)
        FfiConverterUInt32.write(value.undeliveredCount, into: &buf)
    }
}


public func FfiConverterTypeHistoryStats_lift(_ buf: RustBuffer) throws -> HistoryStats {
    return try FfiConverterTypeHistoryStats.lift(buf)
}

public func FfiConverterTypeHistoryStats_lower(_ value: HistoryStats) -> RustBuffer {
    return FfiConverterTypeHistoryStats.lower(value)
}


public struct IdentityInfo {
    public var identityId: String?
    public var publicKeyHex: String?
    public var initialized: Bool
    public var nickname: String?
    public var libp2pPeerId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityId: String?, publicKeyHex: String?, initialized: Bool, nickname: String?, libp2pPeerId: String?) {
        self.identityId = identityId
        self.publicKeyHex = publicKeyHex
        self.initialized = initialized
        self.nickname = nickname
        self.libp2pPeerId = libp2pPeerId
    }
}



extension IdentityInfo: Equatable, Hashable {
    public static func ==(lhs: IdentityInfo, rhs: IdentityInfo) -> Bool {
        if lhs.identityId != rhs.identityId {
            return false
        }
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        if lhs.initialized != rhs.initialized {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.libp2pPeerId != rhs.libp2pPeerId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityId)
        hasher.combine(publicKeyHex)
        hasher.combine(initialized)
        hasher.combine(nickname)
        hasher.combine(libp2pPeerId)
    }
}


public struct FfiConverterTypeIdentityInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityInfo {
        return
            try IdentityInfo(
                identityId: FfiConverterOptionString.read(from: &buf), 
                publicKeyHex: FfiConverterOptionString.read(from: &buf), 
                initialized: FfiConverterBool.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                libp2pPeerId: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.identityId, into: &buf)
        FfiConverterOptionString.write(value.publicKeyHex, into: &buf)
        FfiConverterBool.write(value.initialized, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterOptionString.write(value.libp2pPeerId, into: &buf)
    }
}


public func FfiConverterTypeIdentityInfo_lift(_ buf: RustBuffer) throws -> IdentityInfo {
    return try FfiConverterTypeIdentityInfo.lift(buf)
}

public func FfiConverterTypeIdentityInfo_lower(_ value: IdentityInfo) -> RustBuffer {
    return FfiConverterTypeIdentityInfo.lower(value)
}


public struct LedgerEntry {
    public var multiaddr: String
    public var peerId: String?
    public var publicKey: String?
    public var nickname: String?
    public var successCount: UInt32
    public var failureCount: UInt32
    public var lastSeen: UInt64?
    public var topics: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(multiaddr: String, peerId: String?, publicKey: String?, nickname: String?, successCount: UInt32, failureCount: UInt32, lastSeen: UInt64?, topics: [String]) {
        self.multiaddr = multiaddr
        self.peerId = peerId
        self.publicKey = publicKey
        self.nickname = nickname
        self.successCount = successCount
        self.failureCount = failureCount
        self.lastSeen = lastSeen
        self.topics = topics
    }
}



extension LedgerEntry: Equatable, Hashable {
    public static func ==(lhs: LedgerEntry, rhs: LedgerEntry) -> Bool {
        if lhs.multiaddr != rhs.multiaddr {
            return false
        }
        if lhs.peerId != rhs.peerId {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.successCount != rhs.successCount {
            return false
        }
        if lhs.failureCount != rhs.failureCount {
            return false
        }
        if lhs.lastSeen != rhs.lastSeen {
            return false
        }
        if lhs.topics != rhs.topics {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(multiaddr)
        hasher.combine(peerId)
        hasher.combine(publicKey)
        hasher.combine(nickname)
        hasher.combine(successCount)
        hasher.combine(failureCount)
        hasher.combine(lastSeen)
        hasher.combine(topics)
    }
}


public struct FfiConverterTypeLedgerEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerEntry {
        return
            try LedgerEntry(
                multiaddr: FfiConverterString.read(from: &buf), 
                peerId: FfiConverterOptionString.read(from: &buf), 
                publicKey: FfiConverterOptionString.read(from: &buf), 
                nickname: FfiConverterOptionString.read(from: &buf), 
                successCount: FfiConverterUInt32.read(from: &buf), 
                failureCount: FfiConverterUInt32.read(from: &buf), 
                lastSeen: FfiConverterOptionUInt64.read(from: &buf), 
                topics: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: LedgerEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.multiaddr, into: &buf)
        FfiConverterOptionString.write(value.peerId, into: &buf)
        FfiConverterOptionString.write(value.publicKey, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterUInt32.write(value.successCount, into: &buf)
        FfiConverterUInt32.write(value.failureCount, into: &buf)
        FfiConverterOptionUInt64.write(value.lastSeen, into: &buf)
        FfiConverterSequenceString.write(value.topics, into: &buf)
    }
}


public func FfiConverterTypeLedgerEntry_lift(_ buf: RustBuffer) throws -> LedgerEntry {
    return try FfiConverterTypeLedgerEntry.lift(buf)
}

public func FfiConverterTypeLedgerEntry_lower(_ value: LedgerEntry) -> RustBuffer {
    return FfiConverterTypeLedgerEntry.lower(value)
}


public struct MeshServiceConfig {
    public var discoveryIntervalMs: UInt32
    public var batteryFloorPct: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(discoveryIntervalMs: UInt32, batteryFloorPct: UInt8) {
        self.discoveryIntervalMs = discoveryIntervalMs
        self.batteryFloorPct = batteryFloorPct
    }
}



extension MeshServiceConfig: Equatable, Hashable {
    public static func ==(lhs: MeshServiceConfig, rhs: MeshServiceConfig) -> Bool {
        if lhs.discoveryIntervalMs != rhs.discoveryIntervalMs {
            return false
        }
        if lhs.batteryFloorPct != rhs.batteryFloorPct {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(discoveryIntervalMs)
        hasher.combine(batteryFloorPct)
    }
}


public struct FfiConverterTypeMeshServiceConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MeshServiceConfig {
        return
            try MeshServiceConfig(
                discoveryIntervalMs: FfiConverterUInt32.read(from: &buf), 
                batteryFloorPct: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: MeshServiceConfig, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.discoveryIntervalMs, into: &buf)
        FfiConverterUInt8.write(value.batteryFloorPct, into: &buf)
    }
}


public func FfiConverterTypeMeshServiceConfig_lift(_ buf: RustBuffer) throws -> MeshServiceConfig {
    return try FfiConverterTypeMeshServiceConfig.lift(buf)
}

public func FfiConverterTypeMeshServiceConfig_lower(_ value: MeshServiceConfig) -> RustBuffer {
    return FfiConverterTypeMeshServiceConfig.lower(value)
}


public struct MeshSettings {
    public var relayEnabled: Bool
    public var maxRelayBudget: UInt32
    public var batteryFloor: UInt8
    public var bleEnabled: Bool
    public var wifiAwareEnabled: Bool
    public var wifiDirectEnabled: Bool
    public var internetEnabled: Bool
    public var discoveryMode: DiscoveryMode
    public var onionRouting: Bool
    public var coverTrafficEnabled: Bool
    public var messagePaddingEnabled: Bool
    public var timingObfuscationEnabled: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(relayEnabled: Bool, maxRelayBudget: UInt32, batteryFloor: UInt8, bleEnabled: Bool, wifiAwareEnabled: Bool, wifiDirectEnabled: Bool, internetEnabled: Bool, discoveryMode: DiscoveryMode, onionRouting: Bool, coverTrafficEnabled: Bool, messagePaddingEnabled: Bool, timingObfuscationEnabled: Bool) {
        self.relayEnabled = relayEnabled
        self.maxRelayBudget = maxRelayBudget
        self.batteryFloor = batteryFloor
        self.bleEnabled = bleEnabled
        self.wifiAwareEnabled = wifiAwareEnabled
        self.wifiDirectEnabled = wifiDirectEnabled
        self.internetEnabled = internetEnabled
        self.discoveryMode = discoveryMode
        self.onionRouting = onionRouting
        self.coverTrafficEnabled = coverTrafficEnabled
        self.messagePaddingEnabled = messagePaddingEnabled
        self.timingObfuscationEnabled = timingObfuscationEnabled
    }
}



extension MeshSettings: Equatable, Hashable {
    public static func ==(lhs: MeshSettings, rhs: MeshSettings) -> Bool {
        if lhs.relayEnabled != rhs.relayEnabled {
            return false
        }
        if lhs.maxRelayBudget != rhs.maxRelayBudget {
            return false
        }
        if lhs.batteryFloor != rhs.batteryFloor {
            return false
        }
        if lhs.bleEnabled != rhs.bleEnabled {
            return false
        }
        if lhs.wifiAwareEnabled != rhs.wifiAwareEnabled {
            return false
        }
        if lhs.wifiDirectEnabled != rhs.wifiDirectEnabled {
            return false
        }
        if lhs.internetEnabled != rhs.internetEnabled {
            return false
        }
        if lhs.discoveryMode != rhs.discoveryMode {
            return false
        }
        if lhs.onionRouting != rhs.onionRouting {
            return false
        }
        if lhs.coverTrafficEnabled != rhs.coverTrafficEnabled {
            return false
        }
        if lhs.messagePaddingEnabled != rhs.messagePaddingEnabled {
            return false
        }
        if lhs.timingObfuscationEnabled != rhs.timingObfuscationEnabled {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(relayEnabled)
        hasher.combine(maxRelayBudget)
        hasher.combine(batteryFloor)
        hasher.combine(bleEnabled)
        hasher.combine(wifiAwareEnabled)
        hasher.combine(wifiDirectEnabled)
        hasher.combine(internetEnabled)
        hasher.combine(discoveryMode)
        hasher.combine(onionRouting)
        hasher.combine(coverTrafficEnabled)
        hasher.combine(messagePaddingEnabled)
        hasher.combine(timingObfuscationEnabled)
    }
}


public struct FfiConverterTypeMeshSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MeshSettings {
        return
            try MeshSettings(
                relayEnabled: FfiConverterBool.read(from: &buf), 
                maxRelayBudget: FfiConverterUInt32.read(from: &buf), 
                batteryFloor: FfiConverterUInt8.read(from: &buf), 
                bleEnabled: FfiConverterBool.read(from: &buf), 
                wifiAwareEnabled: FfiConverterBool.read(from: &buf), 
                wifiDirectEnabled: FfiConverterBool.read(from: &buf), 
                internetEnabled: FfiConverterBool.read(from: &buf), 
                discoveryMode: FfiConverterTypeDiscoveryMode.read(from: &buf), 
                onionRouting: FfiConverterBool.read(from: &buf), 
                coverTrafficEnabled: FfiConverterBool.read(from: &buf), 
                messagePaddingEnabled: FfiConverterBool.read(from: &buf), 
                timingObfuscationEnabled: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MeshSettings, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.relayEnabled, into: &buf)
        FfiConverterUInt32.write(value.maxRelayBudget, into: &buf)
        FfiConverterUInt8.write(value.batteryFloor, into: &buf)
        FfiConverterBool.write(value.bleEnabled, into: &buf)
        FfiConverterBool.write(value.wifiAwareEnabled, into: &buf)
        FfiConverterBool.write(value.wifiDirectEnabled, into: &buf)
        FfiConverterBool.write(value.internetEnabled, into: &buf)
        FfiConverterTypeDiscoveryMode.write(value.discoveryMode, into: &buf)
        FfiConverterBool.write(value.onionRouting, into: &buf)
        FfiConverterBool.write(value.coverTrafficEnabled, into: &buf)
        FfiConverterBool.write(value.messagePaddingEnabled, into: &buf)
        FfiConverterBool.write(value.timingObfuscationEnabled, into: &buf)
    }
}


public func FfiConverterTypeMeshSettings_lift(_ buf: RustBuffer) throws -> MeshSettings {
    return try FfiConverterTypeMeshSettings.lift(buf)
}

public func FfiConverterTypeMeshSettings_lower(_ value: MeshSettings) -> RustBuffer {
    return FfiConverterTypeMeshSettings.lower(value)
}


public struct MessageRecord {
    public var id: String
    public var direction: MessageDirection
    public var peerId: String
    public var content: String
    public var timestamp: UInt64
    public var delivered: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, direction: MessageDirection, peerId: String, content: String, timestamp: UInt64, delivered: Bool) {
        self.id = id
        self.direction = direction
        self.peerId = peerId
        self.content = content
        self.timestamp = timestamp
        self.delivered = delivered
    }
}



extension MessageRecord: Equatable, Hashable {
    public static func ==(lhs: MessageRecord, rhs: MessageRecord) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        if lhs.peerId != rhs.peerId {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.delivered != rhs.delivered {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(direction)
        hasher.combine(peerId)
        hasher.combine(content)
        hasher.combine(timestamp)
        hasher.combine(delivered)
    }
}


public struct FfiConverterTypeMessageRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageRecord {
        return
            try MessageRecord(
                id: FfiConverterString.read(from: &buf), 
                direction: FfiConverterTypeMessageDirection.read(from: &buf), 
                peerId: FfiConverterString.read(from: &buf), 
                content: FfiConverterString.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                delivered: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MessageRecord, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeMessageDirection.write(value.direction, into: &buf)
        FfiConverterString.write(value.peerId, into: &buf)
        FfiConverterString.write(value.content, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterBool.write(value.delivered, into: &buf)
    }
}


public func FfiConverterTypeMessageRecord_lift(_ buf: RustBuffer) throws -> MessageRecord {
    return try FfiConverterTypeMessageRecord.lift(buf)
}

public func FfiConverterTypeMessageRecord_lower(_ value: MessageRecord) -> RustBuffer {
    return FfiConverterTypeMessageRecord.lower(value)
}


public struct PreparedMessage {
    public var messageId: String
    public var envelopeData: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(messageId: String, envelopeData: Data) {
        self.messageId = messageId
        self.envelopeData = envelopeData
    }
}



extension PreparedMessage: Equatable, Hashable {
    public static func ==(lhs: PreparedMessage, rhs: PreparedMessage) -> Bool {
        if lhs.messageId != rhs.messageId {
            return false
        }
        if lhs.envelopeData != rhs.envelopeData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(messageId)
        hasher.combine(envelopeData)
    }
}


public struct FfiConverterTypePreparedMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreparedMessage {
        return
            try PreparedMessage(
                messageId: FfiConverterString.read(from: &buf), 
                envelopeData: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: PreparedMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.messageId, into: &buf)
        FfiConverterData.write(value.envelopeData, into: &buf)
    }
}


public func FfiConverterTypePreparedMessage_lift(_ buf: RustBuffer) throws -> PreparedMessage {
    return try FfiConverterTypePreparedMessage.lift(buf)
}

public func FfiConverterTypePreparedMessage_lower(_ value: PreparedMessage) -> RustBuffer {
    return FfiConverterTypePreparedMessage.lower(value)
}


public struct RelayAdjustment {
    public var maxPerHour: UInt32
    public var priorityThreshold: UInt8
    public var maxPayloadBytes: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxPerHour: UInt32, priorityThreshold: UInt8, maxPayloadBytes: UInt32) {
        self.maxPerHour = maxPerHour
        self.priorityThreshold = priorityThreshold
        self.maxPayloadBytes = maxPayloadBytes
    }
}



extension RelayAdjustment: Equatable, Hashable {
    public static func ==(lhs: RelayAdjustment, rhs: RelayAdjustment) -> Bool {
        if lhs.maxPerHour != rhs.maxPerHour {
            return false
        }
        if lhs.priorityThreshold != rhs.priorityThreshold {
            return false
        }
        if lhs.maxPayloadBytes != rhs.maxPayloadBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxPerHour)
        hasher.combine(priorityThreshold)
        hasher.combine(maxPayloadBytes)
    }
}


public struct FfiConverterTypeRelayAdjustment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayAdjustment {
        return
            try RelayAdjustment(
                maxPerHour: FfiConverterUInt32.read(from: &buf), 
                priorityThreshold: FfiConverterUInt8.read(from: &buf), 
                maxPayloadBytes: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RelayAdjustment, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.maxPerHour, into: &buf)
        FfiConverterUInt8.write(value.priorityThreshold, into: &buf)
        FfiConverterUInt32.write(value.maxPayloadBytes, into: &buf)
    }
}


public func FfiConverterTypeRelayAdjustment_lift(_ buf: RustBuffer) throws -> RelayAdjustment {
    return try FfiConverterTypeRelayAdjustment.lift(buf)
}

public func FfiConverterTypeRelayAdjustment_lower(_ value: RelayAdjustment) -> RustBuffer {
    return FfiConverterTypeRelayAdjustment.lower(value)
}


public struct ServiceStats {
    public var peersDiscovered: UInt32
    public var messagesRelayed: UInt32
    public var bytesTransferred: UInt64
    public var uptimeSecs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(peersDiscovered: UInt32, messagesRelayed: UInt32, bytesTransferred: UInt64, uptimeSecs: UInt64) {
        self.peersDiscovered = peersDiscovered
        self.messagesRelayed = messagesRelayed
        self.bytesTransferred = bytesTransferred
        self.uptimeSecs = uptimeSecs
    }
}



extension ServiceStats: Equatable, Hashable {
    public static func ==(lhs: ServiceStats, rhs: ServiceStats) -> Bool {
        if lhs.peersDiscovered != rhs.peersDiscovered {
            return false
        }
        if lhs.messagesRelayed != rhs.messagesRelayed {
            return false
        }
        if lhs.bytesTransferred != rhs.bytesTransferred {
            return false
        }
        if lhs.uptimeSecs != rhs.uptimeSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(peersDiscovered)
        hasher.combine(messagesRelayed)
        hasher.combine(bytesTransferred)
        hasher.combine(uptimeSecs)
    }
}


public struct FfiConverterTypeServiceStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServiceStats {
        return
            try ServiceStats(
                peersDiscovered: FfiConverterUInt32.read(from: &buf), 
                messagesRelayed: FfiConverterUInt32.read(from: &buf), 
                bytesTransferred: FfiConverterUInt64.read(from: &buf), 
                uptimeSecs: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ServiceStats, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.peersDiscovered, into: &buf)
        FfiConverterUInt32.write(value.messagesRelayed, into: &buf)
        FfiConverterUInt64.write(value.bytesTransferred, into: &buf)
        FfiConverterUInt64.write(value.uptimeSecs, into: &buf)
    }
}


public func FfiConverterTypeServiceStats_lift(_ buf: RustBuffer) throws -> ServiceStats {
    return try FfiConverterTypeServiceStats.lift(buf)
}

public func FfiConverterTypeServiceStats_lower(_ value: ServiceStats) -> RustBuffer {
    return FfiConverterTypeServiceStats.lower(value)
}


public struct SignatureResult {
    public var signature: Data
    public var publicKeyHex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signature: Data, publicKeyHex: String) {
        self.signature = signature
        self.publicKeyHex = publicKeyHex
    }
}



extension SignatureResult: Equatable, Hashable {
    public static func ==(lhs: SignatureResult, rhs: SignatureResult) -> Bool {
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signature)
        hasher.combine(publicKeyHex)
    }
}


public struct FfiConverterTypeSignatureResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureResult {
        return
            try SignatureResult(
                signature: FfiConverterData.read(from: &buf), 
                publicKeyHex: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignatureResult, into buf: inout [UInt8]) {
        FfiConverterData.write(value.signature, into: &buf)
        FfiConverterString.write(value.publicKeyHex, into: &buf)
    }
}


public func FfiConverterTypeSignatureResult_lift(_ buf: RustBuffer) throws -> SignatureResult {
    return try FfiConverterTypeSignatureResult.lift(buf)
}

public func FfiConverterTypeSignatureResult_lower(_ value: SignatureResult) -> RustBuffer {
    return FfiConverterTypeSignatureResult.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AdjustmentProfile {
    
    case maximum
    case high
    case standard
    case reduced
    case minimal
}


public struct FfiConverterTypeAdjustmentProfile: FfiConverterRustBuffer {
    typealias SwiftType = AdjustmentProfile

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AdjustmentProfile {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .maximum
        
        case 2: return .high
        
        case 3: return .standard
        
        case 4: return .reduced
        
        case 5: return .minimal
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AdjustmentProfile, into buf: inout [UInt8]) {
        switch value {
        
        
        case .maximum:
            writeInt(&buf, Int32(1))
        
        
        case .high:
            writeInt(&buf, Int32(2))
        
        
        case .standard:
            writeInt(&buf, Int32(3))
        
        
        case .reduced:
            writeInt(&buf, Int32(4))
        
        
        case .minimal:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeAdjustmentProfile_lift(_ buf: RustBuffer) throws -> AdjustmentProfile {
    return try FfiConverterTypeAdjustmentProfile.lift(buf)
}

public func FfiConverterTypeAdjustmentProfile_lower(_ value: AdjustmentProfile) -> RustBuffer {
    return FfiConverterTypeAdjustmentProfile.lower(value)
}



extension AdjustmentProfile: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Canonical connection-path state contract for all clients.
 */

public enum ConnectionPathState {
    
    case disconnected
    case bootstrapping
    case directPreferred
    case relayFallback
    case relayOnly
}


public struct FfiConverterTypeConnectionPathState: FfiConverterRustBuffer {
    typealias SwiftType = ConnectionPathState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionPathState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disconnected
        
        case 2: return .bootstrapping
        
        case 3: return .directPreferred
        
        case 4: return .relayFallback
        
        case 5: return .relayOnly
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConnectionPathState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disconnected:
            writeInt(&buf, Int32(1))
        
        
        case .bootstrapping:
            writeInt(&buf, Int32(2))
        
        
        case .directPreferred:
            writeInt(&buf, Int32(3))
        
        
        case .relayFallback:
            writeInt(&buf, Int32(4))
        
        
        case .relayOnly:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeConnectionPathState_lift(_ buf: RustBuffer) throws -> ConnectionPathState {
    return try FfiConverterTypeConnectionPathState.lift(buf)
}

public func FfiConverterTypeConnectionPathState_lower(_ value: ConnectionPathState) -> RustBuffer {
    return FfiConverterTypeConnectionPathState.lower(value)
}



extension ConnectionPathState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DiscoveryMode {
    
    case normal
    case cautious
    case paranoid
}


public struct FfiConverterTypeDiscoveryMode: FfiConverterRustBuffer {
    typealias SwiftType = DiscoveryMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DiscoveryMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .normal
        
        case 2: return .cautious
        
        case 3: return .paranoid
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DiscoveryMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .normal:
            writeInt(&buf, Int32(1))
        
        
        case .cautious:
            writeInt(&buf, Int32(2))
        
        
        case .paranoid:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeDiscoveryMode_lift(_ buf: RustBuffer) throws -> DiscoveryMode {
    return try FfiConverterTypeDiscoveryMode.lift(buf)
}

public func FfiConverterTypeDiscoveryMode_lower(_ value: DiscoveryMode) -> RustBuffer {
    return FfiConverterTypeDiscoveryMode.lower(value)
}



extension DiscoveryMode: Equatable, Hashable {}




public enum IronCoreError {

    
    
    case NotInitialized(message: String)
    
    case AlreadyRunning(message: String)
    
    case StorageError(message: String)
    
    case CryptoError(message: String)
    
    case NetworkError(message: String)
    
    case InvalidInput(message: String)
    
    case Internal(message: String)
    
}


public struct FfiConverterTypeIronCoreError: FfiConverterRustBuffer {
    typealias SwiftType = IronCoreError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IronCoreError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NotInitialized(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .AlreadyRunning(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .StorageError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .CryptoError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .NetworkError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidInput(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .Internal(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IronCoreError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .NotInitialized(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .AlreadyRunning(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .StorageError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .CryptoError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .NetworkError(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvalidInput(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .Internal(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))

        
        }
    }
}


extension IronCoreError: Equatable, Hashable {}

extension IronCoreError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageDirection {
    
    case sent
    case received
}


public struct FfiConverterTypeMessageDirection: FfiConverterRustBuffer {
    typealias SwiftType = MessageDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sent
        
        case 2: return .received
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sent:
            writeInt(&buf, Int32(1))
        
        
        case .received:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeMessageDirection_lift(_ buf: RustBuffer) throws -> MessageDirection {
    return try FfiConverterTypeMessageDirection.lift(buf)
}

public func FfiConverterTypeMessageDirection_lower(_ value: MessageDirection) -> RustBuffer {
    return FfiConverterTypeMessageDirection.lower(value)
}



extension MessageDirection: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MotionState {
    
    case still
    case walking
    case running
    case automotive
    case unknown
}


public struct FfiConverterTypeMotionState: FfiConverterRustBuffer {
    typealias SwiftType = MotionState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MotionState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .still
        
        case 2: return .walking
        
        case 3: return .running
        
        case 4: return .automotive
        
        case 5: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MotionState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .still:
            writeInt(&buf, Int32(1))
        
        
        case .walking:
            writeInt(&buf, Int32(2))
        
        
        case .running:
            writeInt(&buf, Int32(3))
        
        
        case .automotive:
            writeInt(&buf, Int32(4))
        
        
        case .unknown:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeMotionState_lift(_ buf: RustBuffer) throws -> MotionState {
    return try FfiConverterTypeMotionState.lift(buf)
}

public func FfiConverterTypeMotionState_lower(_ value: MotionState) -> RustBuffer {
    return FfiConverterTypeMotionState.lower(value)
}



extension MotionState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ServiceState {
    
    case stopped
    case starting
    case running
    case stopping
}


public struct FfiConverterTypeServiceState: FfiConverterRustBuffer {
    typealias SwiftType = ServiceState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServiceState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .stopped
        
        case 2: return .starting
        
        case 3: return .running
        
        case 4: return .stopping
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ServiceState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .stopped:
            writeInt(&buf, Int32(1))
        
        
        case .starting:
            writeInt(&buf, Int32(2))
        
        
        case .running:
            writeInt(&buf, Int32(3))
        
        
        case .stopping:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeServiceState_lift(_ buf: RustBuffer) throws -> ServiceState {
    return try FfiConverterTypeServiceState.lift(buf)
}

public func FfiConverterTypeServiceState_lower(_ value: ServiceState) -> RustBuffer {
    return FfiConverterTypeServiceState.lower(value)
}



extension ServiceState: Equatable, Hashable {}






public protocol CoreDelegate : AnyObject {
    
    func onPeerDiscovered(peerId: String) 
    
    func onPeerDisconnected(peerId: String) 
    
    func onPeerIdentified(peerId: String, agentVersion: String, listenAddrs: [String]) 
    
    func onMessageReceived(senderId: String, senderPublicKeyHex: String, messageId: String, senderTimestamp: UInt64, data: Data) 
    
    func onReceiptReceived(messageId: String, status: String) 
    
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCoreDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceCoreDelegate = UniffiVTableCallbackInterfaceCoreDelegate(
        onPeerDiscovered: { (
            uniffiHandle: UInt64,
            peerId: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCoreDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onPeerDiscovered(
                     peerId: try FfiConverterString.lift(peerId)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onPeerDisconnected: { (
            uniffiHandle: UInt64,
            peerId: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCoreDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onPeerDisconnected(
                     peerId: try FfiConverterString.lift(peerId)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onPeerIdentified: { (
            uniffiHandle: UInt64,
            peerId: RustBuffer,
            agentVersion: RustBuffer,
            listenAddrs: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCoreDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onPeerIdentified(
                     peerId: try FfiConverterString.lift(peerId),
                     agentVersion: try FfiConverterString.lift(agentVersion),
                     listenAddrs: try FfiConverterSequenceString.lift(listenAddrs)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onMessageReceived: { (
            uniffiHandle: UInt64,
            senderId: RustBuffer,
            senderPublicKeyHex: RustBuffer,
            messageId: RustBuffer,
            senderTimestamp: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCoreDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onMessageReceived(
                     senderId: try FfiConverterString.lift(senderId),
                     senderPublicKeyHex: try FfiConverterString.lift(senderPublicKeyHex),
                     messageId: try FfiConverterString.lift(messageId),
                     senderTimestamp: try FfiConverterUInt64.lift(senderTimestamp),
                     data: try FfiConverterData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onReceiptReceived: { (
            uniffiHandle: UInt64,
            messageId: RustBuffer,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCoreDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onReceiptReceived(
                     messageId: try FfiConverterString.lift(messageId),
                     status: try FfiConverterString.lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceCoreDelegate.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface CoreDelegate: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitCoreDelegate() {
    uniffi_scmessenger_core_fn_init_callback_vtable_coredelegate(&UniffiCallbackInterfaceCoreDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceCoreDelegate {
    fileprivate static var handleMap = UniffiHandleMap<CoreDelegate>()
}

extension FfiConverterCallbackInterfaceCoreDelegate : FfiConverter {
    typealias SwiftType = CoreDelegate
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}




public protocol PlatformBridge : AnyObject {
    
    func onBatteryChanged(batteryPct: UInt8, isCharging: Bool) 
    
    func onNetworkChanged(hasWifi: Bool, hasCellular: Bool) 
    
    func onMotionChanged(motion: MotionState) 
    
    func onBleDataReceived(peerId: String, data: Data) 
    
    func onEnteringBackground() 
    
    func onEnteringForeground() 
    
    func sendBlePacket(peerId: String, data: Data) 
    
}



// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePlatformBridge {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfacePlatformBridge = UniffiVTableCallbackInterfacePlatformBridge(
        onBatteryChanged: { (
            uniffiHandle: UInt64,
            batteryPct: UInt8,
            isCharging: Int8,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePlatformBridge.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onBatteryChanged(
                     batteryPct: try FfiConverterUInt8.lift(batteryPct),
                     isCharging: try FfiConverterBool.lift(isCharging)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onNetworkChanged: { (
            uniffiHandle: UInt64,
            hasWifi: Int8,
            hasCellular: Int8,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePlatformBridge.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onNetworkChanged(
                     hasWifi: try FfiConverterBool.lift(hasWifi),
                     hasCellular: try FfiConverterBool.lift(hasCellular)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onMotionChanged: { (
            uniffiHandle: UInt64,
            motion: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePlatformBridge.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onMotionChanged(
                     motion: try FfiConverterTypeMotionState.lift(motion)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onBleDataReceived: { (
            uniffiHandle: UInt64,
            peerId: RustBuffer,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePlatformBridge.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onBleDataReceived(
                     peerId: try FfiConverterString.lift(peerId),
                     data: try FfiConverterData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onEnteringBackground: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePlatformBridge.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onEnteringBackground(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onEnteringForeground: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePlatformBridge.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onEnteringForeground(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        sendBlePacket: { (
            uniffiHandle: UInt64,
            peerId: RustBuffer,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePlatformBridge.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.sendBlePacket(
                     peerId: try FfiConverterString.lift(peerId),
                     data: try FfiConverterData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfacePlatformBridge.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PlatformBridge: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitPlatformBridge() {
    uniffi_scmessenger_core_fn_init_callback_vtable_platformbridge(&UniffiCallbackInterfacePlatformBridge.vtable)
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfacePlatformBridge {
    fileprivate static var handleMap = UniffiHandleMap<PlatformBridge>()
}

extension FfiConverterCallbackInterfacePlatformBridge : FfiConverter {
    typealias SwiftType = PlatformBridge
    typealias FfiType = UInt64

    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIronCore: FfiConverterRustBuffer {
    typealias SwiftType = IronCore?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIronCore.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIronCore.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeContact: FfiConverterRustBuffer {
    typealias SwiftType = Contact?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeContact.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeContact.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMessageRecord: FfiConverterRustBuffer {
    typealias SwiftType = MessageRecord?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessageRecord.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessageRecord.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceCoreDelegate: FfiConverterRustBuffer {
    typealias SwiftType = CoreDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceCoreDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceCoreDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfacePlatformBridge: FfiConverterRustBuffer {
    typealias SwiftType = PlatformBridge?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfacePlatformBridge.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfacePlatformBridge.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeContact: FfiConverterRustBuffer {
    typealias SwiftType = [Contact]

    public static func write(_ value: [Contact], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContact.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Contact] {
        let len: Int32 = try readInt(&buf)
        var seq = [Contact]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContact.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLedgerEntry: FfiConverterRustBuffer {
    typealias SwiftType = [LedgerEntry]

    public static func write(_ value: [LedgerEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLedgerEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LedgerEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [LedgerEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLedgerEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMessageRecord: FfiConverterRustBuffer {
    typealias SwiftType = [MessageRecord]

    public static func write(_ value: [MessageRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessageRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MessageRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [MessageRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessageRecord.read(from: &buf))
        }
        return seq
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_scmessenger_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_autoadjustengine_clear_overrides() != 5093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_autoadjustengine_compute_ble_adjustment() != 27172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_autoadjustengine_compute_profile() != 23610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_autoadjustengine_compute_relay_adjustment() != 18253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_autoadjustengine_override_ble_scan_interval() != 3320) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_autoadjustengine_override_relay_max_per_hour() != 39971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_bootstrapresolver_resolve() != 35995) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_bootstrapresolver_static_fallback() != 1236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_add() != 49365) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_count() != 6258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_flush() != 12743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_get() != 7325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_list() != 54866) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_remove() != 64184) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_search() != 8112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_set_local_nickname() != 27487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_set_nickname() != 37981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_contactmanager_update_last_seen() != 8449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_add() != 35083) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_clear() != 9710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_clear_conversation() != 49661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_conversation() != 18795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_count() != 35021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_delete() != 37935) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_enforce_retention() != 40579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_flush() != 50033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_get() != 40713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_mark_delivered() != 49295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_prune_before() != 62632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_recent() != 56247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_remove_conversation() != 38936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_search() != 11689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_historymanager_stats() != 45938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_export_identity_backup() != 49536) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_extract_public_key_from_peer_id() != 39145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_get_identity_info() != 10640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_import_identity_backup() != 7432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_inbox_count() != 64990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_initialize_identity() != 61190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_is_running() != 48214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_mark_message_sent() != 1211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_outbox_count() != 26099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_prepare_cover_traffic() != 15820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_prepare_message() != 24979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_prepare_message_with_id() != 51238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_prepare_receipt() != 37483) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_set_delegate() != 56502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_set_nickname() != 20532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_sign_data() != 21683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_start() != 57588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_stop() != 28908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ironcore_verify_signature() != 26914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ledgermanager_all_known_topics() != 39576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ledgermanager_annotate_identity() != 63553) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ledgermanager_dialable_addresses() != 27481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ledgermanager_get_preferred_relays() != 45636) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ledgermanager_load() != 59015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ledgermanager_record_connection() != 14496) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ledgermanager_record_failure() != 11981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ledgermanager_save() != 63201) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_ledgermanager_summary() != 25042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_export_diagnostics() != 20773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_get_connection_path_state() != 43832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_get_core() != 47720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_get_nat_status() != 65008) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_get_state() != 8067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_get_stats() != 43801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_get_swarm_bridge() != 46469) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_on_data_received() != 32989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_on_peer_disconnected() != 15352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_on_peer_discovered() != 12357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_pause() != 13255) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_reset_stats() != 37576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_resume() != 8459) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_set_bootstrap_nodes() != 44559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_set_platform_bridge() != 10542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_set_relay_budget() != 64683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_start() != 4434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_start_swarm() != 44270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_stop() != 57632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshservice_update_device_state() != 32579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshsettingsmanager_default_settings() != 13041) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshsettingsmanager_load() != 60042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshsettingsmanager_save() != 33224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_meshsettingsmanager_validate() != 18761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_dial() != 24277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_get_external_addresses() != 49043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_get_listeners() != 59843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_get_peers() != 42047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_get_topics() != 29012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_publish_topic() != 65103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_send_message() != 48419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_send_to_all_peers() != 18109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_shutdown() != 22199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_subscribe_topic() != 21077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_swarmbridge_unsubscribe_topic() != 53383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_autoadjustengine_new() != 8336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_bootstrapresolver_new() != 2325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_contactmanager_new() != 10934) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_historymanager_new() != 41005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_ironcore_new() != 37487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_ironcore_with_storage() != 63740) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_ledgermanager_new() != 61074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_meshservice_new() != 41294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_meshservice_with_storage() != 13520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_meshsettingsmanager_new() != 63874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_constructor_swarmbridge_new() != 28844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_coredelegate_on_peer_discovered() != 60014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_coredelegate_on_peer_disconnected() != 46680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_coredelegate_on_peer_identified() != 17729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_coredelegate_on_message_received() != 39348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_coredelegate_on_receipt_received() != 33338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_platformbridge_on_battery_changed() != 3117) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_platformbridge_on_network_changed() != 41497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_platformbridge_on_motion_changed() != 26884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_platformbridge_on_ble_data_received() != 28646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_platformbridge_on_entering_background() != 32558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_platformbridge_on_entering_foreground() != 61731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_scmessenger_core_checksum_method_platformbridge_send_ble_packet() != 27080) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitCoreDelegate()
    uniffiCallbackInitPlatformBridge()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all